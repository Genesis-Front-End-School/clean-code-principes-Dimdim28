I implemented the Singleton GoF pattern for the instance of the axios client. Singleton guarantees the existence of only one object of a certain class, and also allows you to reach this object from anywhere in the program.

```js
import axios, { AxiosInstance } from 'axios';

export class SingletonInstance {
  private static instance: AxiosInstance;

  private constructor() { }

  public static getInstance(): AxiosInstance {
    if (!this.instance) this.instance = axios.create({
      baseURL: `${process.env.NEXT_PUBLIC_API_HOST}/${process.env.NEXT_PUBLIC_API_VERSION}`,
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${process.env.NEXT_PUBLIC_API_TOKEN}`,
      },
    });

    return this.instance;
  }
}

export default SingletonInstance.getInstance();

```

I have also used redux here, so I have here an example of the using built-in builder pattern which allows constructing complex objects step by step. In the redux we have ability to work with the extra reducers with using builder. We can add as much cases as we want with using addcase() method.

```ts
 addCase<ActionCreator extends TypedActionCreator<string>>(actionCreator: ActionCreator, reducer: CaseReducer<State, ReturnType<ActionCreator>>): ActionReducerMapBuilder<State>;
    /**
     * Adds a case reducer to handle a single exact action type.
     * @remarks
     * All calls to `builder.addCase` must come before any calls to `builder.addMatcher` or `builder.addDefaultCase`.
     * @param actionCreator - Either a plain action type string, or an action creator generated by [`createAction`](./createAction) that can be used to determine the action type.
     * @param reducer - The actual case reducer function.
     */
```


## lessons slice

```js
import { createSlice } from '@reduxjs/toolkit';

import { Status } from '../types';

import { fetchLessons } from './asyncActions';
import { LessonsSliceState } from './types';

const initialState: LessonsSliceState = {
  status: Status.LOADING,
  lessons: [],
  courseInfo: null,
};

const lessonsSlice = createSlice({
  name: 'lessons',
  initialState,
  reducers: {},
  extraReducers: builder => {
    builder.addCase(fetchLessons.pending, state => {
      delete state.Error;
      state.status = Status.LOADING;
    });
    builder.addCase(fetchLessons.fulfilled, (state, action) => {
      const { lessons, ...courseInfo } = action.payload;
      state.lessons = lessons;
      state.courseInfo = courseInfo;
      state.status = Status.SUCCESS;
    });
    builder.addCase(fetchLessons.rejected, (state, action) => {
      state.status = Status.ERROR;
      state.Error = action.error.message;
    });
  },
});

export default lessonsSlice.reducer;
```

## courses slice

```js
import { createSlice } from '@reduxjs/toolkit';

import { Status } from '../types';

import { fetchCourses } from './asyncActions';
import { CoursesSliceState } from './types';

const initialState: CoursesSliceState = {
  status: Status.LOADING,
  courses: [],
  currentPage: 1,
};

const coursesSlice = createSlice({
  name: 'courses',
  initialState,
  reducers: {
    setCurrentPage(state, action) {
      state.currentPage = action.payload;
    },
  },
  extraReducers: builder => {
    builder.addCase(fetchCourses.pending, state => {
      delete state.Error;
      state.status = Status.LOADING;
    });
    builder.addCase(fetchCourses.fulfilled, (state, action) => {
      state.courses = action.payload;
      state.status = Status.SUCCESS;
    });
    builder.addCase(fetchCourses.rejected, (state, action) => {
      state.status = Status.ERROR;
      state.Error = action.error.message;
    });
  },
});

export const { setCurrentPage } = coursesSlice.actions;

export default coursesSlice.reducer;
```